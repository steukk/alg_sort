Работа Штойк Валерии, группа УИБО-14-24

1) Сортировка выбором (Selection Sort) — на каждом шаге алгоритма находят минимальный элемент среди последних и меняют его местами с текущим элементом в массиве алгоритм на с++
При запуске кода на C++ на примере массив [64, 25, 12, 22, 11], получим отсортированный массив [11, 12, 22, 25, 64] 

Анализ алгоритма сортировки выбором:
Алгоритм последовательно перебирает элементы массива и находит минимальный элемент среди ещё не обработанных частей массива. Найденный минимальный элемент помещается на своё правильное место, начиная с первого индекса неотсортированного участка.
На первом шаге алгоритм рассматривает всю длину массива и выбирает минимальное значение (например, число 11), которое заменяет собой первое значение массива.
Далее начинается обработка следующего фрагмента массива, начиная со второго элемента. Опять же находится минимальное значение среди оставшихся элементов (например, теперь это 12) и оно ставится на второе место.
Процесс продолжается для каждого шага до тех пор, пока вся длина массива не будет отсортирована.

Алгоритм имеет временную сложность: O(n2), потому что включает два вложенных цикла:
Один внешний цикл для выбора начала отсортированной части.
Один внутренний цикл для поиска минимального элемента среди оставшихся.


2) Сортировка обменом (пузырьком) (Bubble Sort) — алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Процесс повторяется до тех
пор, пока список полностью не отсортируется.
Анализ алгоритма сортировки обменом:
-Сначала определяется длина списка с помощью len(arr).
-Внешний цикл устанавливает число проходов по всему списку, так как каждый проход гарантирует размещение одного наибольшего элемента в конце.
-Внутренний цикл проходит по элементам, которые ещё не отсортированы (уменьшается на i, количество уже отсортированных элементов).
-Каждый раз сравниваются пары соседних элементов: если левый больше правого, они меняются местами.
-Итерации повторяются, пока весь список не станет отсортированным — когда за один проход не произойдет ни одной перестановки.

Временная сложность: Пузырьковая сортировка в худшем и среднем случае имеет временную сложность O(n2), потому что она использует вложенные циклы, каждый из которых зависит от размера списка nn.

3)Сортировка слиянием (Merge Sort) — алгоритм состоит в разделении массива пополам, сортировке половин и их слиянии.

Алгоритм сортировки вставками начинает с предположения, что первый элемент отсортирован. Затем он поочерёдно берёт каждый следующий элемент массива (с индексом i начиная с 1) и вставляет его в уже отсортированную часть массива (справа от начала до i-1).
Для каждого элемента key, внутренний цикл перемещается по отсортированной части массива слева направо и сдвигает элементы, которые больше key, вправо, чтобы освободить место для key. Когда подходящее место найдено (то есть элемент меньше или равен key), вставляется key.

Временная сложность алгоритма сортировки вставками — O(n2).


4) Сортировка Шелла (Shellsort) — является модификацией сортировки вставками, сортирует между собой элементы, стоящие на местах, кратных определённому шагу.
Алгоритм разбит на две функции.
-insertion_sort_gap выполняет сортировку вставками не для всего массива подряд, а проходится по элементам с фиксированным шагом (gap), начиная с позиции start. Это соответствует логике сортировки подсписки, образованные элементами на расстоянии шага.
-shell_sort управляет выбором шага gap, на каждом шаге разбивает массив на несколько таких подсписков (от 0 до gap-1) и вызывает insertion_sort_gap для каждого.
Временная сложность алгоритма: O(n^1.5)

5)Быстрая сортировка (Quick Sort) — один из самых известных и широко используемых алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них.
Алгоритмы:
-Основная функция — quickSort, которая принимает массив и индексы начала и конца сортируемой части.
-Функция partition выбирает опорный элемент (pivot), здесь это последний элемент в текущем подмассиве.
-В цикле элементы, меньше опорного, перемещаются влево, больше — вправо.
-После циклов опорный элемент ставится на своё "правильное" место, и функция возвращает его индекс.
-Затем quickSort рекурсивно вызывается для левой и правой частей массива, разделённых опорным элементом.
-Рекурсия продолжается, пока подмассивы не станут слишком маленькими для дальнейшей сортировки.
Временная сложность: O(nlogn)

6)Пирамидальная сортировка — алгоритм строит кучу из исходного списка, затем постепенно
извлекает наибольший элемент из кучи и помещает его в конец списка.
Алгоритм:
-Функция heapify поддерживает свойство кучи (максимальной куче в данном случае) начиная с индекса i для поддерева размером n.
+Выбирается текущий узел как «наибольший» по сравнению с его левым и правым потомками.
+Если какой-то из потомков больше текущего, меняются местами и рекурсивно вызывается heapify для этого поддерева.
-В heapSort сначала создаётся максимальная куча из входного массива, вызывая heapify для всех не листовых узлов в обратном порядке (середина массива к началу).
-Затем происходит сортировка:
+Самый большой элемент (корень кучи) меняется с последним элементом массива.
+Размер рассматриваемой кучи уменьшается на 1.
+Для нового корня вызывается heapify, чтобы поддержать максимальную кучу.
-В конце функция main выводит отсортированный массив.

7)Последовательный (линейный) поиск — простейший вид поиска заданного элемента на некотором множестве. Осуществляется путём последовательного сравнения очередного рассматриваемого значения с искомым до тех пор, пока эти значения не совпадут. Этот метод является наименее эффективным, так как его временная сложность составляет O(n), где n — количество элементов в списке. Однако он прост в реализации и может быть полезен для небольших списков или в тех случаях, когда данные не отсортированы.

Алгоритм:
-Функция linear_search принимает два аргумента: список arr и целевой элемент target. Она перебирает все элементы списка по порядку, сравнивая каждый элемент с target. Если элемент совпадает с искомым, функция возвращает индекс этого элемента, что означает, что поиск завершился успешно. Если цикл завершился без нахождения искомого элемента, функция возвращает -1, что означает, что элемент не найден в списке.
-Затем создается список numbers с несколькими числами. Указан искомый элемент 58. Функция вызывается для поиска этого элемента. В результате программа выводит, на какой позиции находится найденный элемент или сообщает, что его нет в списке.

Временная сложность алгоритма: O(n)

7) Бинарный (двоичный, дихотомический) поиск — это поиск заданного элемента на упорядоченном множестве, осуществляемый путём неоднократного деления этого множества на две части таким образом, что искомый элемент попадает в одну из этих частей. Поиск
заканчивается при совпадении искомого элемента с элементом, который является границей между частями множества или при отсутствии искомого элемента. Преимуществом бинарного поиска является более низкая трудоёмкость по сравнению с последовательным поиском.
Недостаток заключается в том, что он применим только на отсортированных множествах.

