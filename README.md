Работа Штойк Валерии, группа УИБО-14-24

### 1) Сортировка выбором (Selection Sort) — на каждом шаге алгоритма находят минимальный элемент среди последних и меняют его местами с текущим элементом в массиве алгоритм на с++


Анализ алгоритма сортировки выбором:
Алгоритм последовательно перебирает элементы массива и находит минимальный элемент среди ещё не обработанных частей массива. Найденный минимальный элемент помещается на своё правильное место, начиная с первого индекса неотсортированного участка.
На первом шаге алгоритм рассматривает всю длину массива и выбирает минимальное значение, которое заменяет собой первое значение массива.
Далее начинается обработка следующего фрагмента массива, начиная со второго элемента. Опять же находится минимальное значение среди оставшихся элементов и оно ставится на второе место.
Процесс продолжается для каждого шага до тех пор, пока вся длина массива не будет отсортирована.

Временная сложность: O(n²)
Почему O(n²): Алгоритм содержит два вложенных цикла. Внешний цикл проходит по каждому элементу массива (n итераций), а внутренний ищет минимальный элемент среди оставшихся (до n итераций). Так как внутренний цикл выполняется для каждой итерации внешнего, в сумме получаем до n × n операций, то есть O(n²).



### 2) Сортировка обменом (пузырьком) (Bubble Sort) — алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется.

Анализ алгоритма сортировки обменом:
-Сначала определяется длина списка с помощью len(arr).
-Внешний цикл устанавливает число проходов по всему списку, так как каждый проход гарантирует размещение одного наибольшего элемента в конце.т
-Внутренний цикл проходит по элементам, которые ещё не отсортированы (уменьшается на i, количество уже отсортированных элементов).
-Каждый раз сравниваются пары соседних элементов: если левый больше правого, они меняются местами.
-Итерации повторяются, пока весь список не станет отсортированным — когда за один проход не произойдет ни одной перестановки.

Временная сложность: O(n²)
Почему O(n²): Алгоритм использует два вложенных цикла: внешний задаёт количество проходов по массиву, а внутренний сравнивает соседние элементы и меняет их местами. Для каждого из n элементов может выполняться до n сравнений, поэтому общая сложность — O(n²).


### 3)Сортировка слиянием (Merge Sort) — алгоритм состоит в разделении массива пополам, сортировке половин и их слиянии.

Алгоритм сортировки вставками начинает с предположения, что первый элемент отсортирован. Затем он поочерёдно берёт каждый следующий элемент массива (с индексом i начиная с 1) и вставляет его в уже отсортированную часть массива (справа от начала до i-1).
Для каждого элемента key, внутренний цикл перемещается по отсортированной части массива слева направо и сдвигает элементы, которые больше key, вправо, чтобы освободить место для key. Когда подходящее место найдено (то есть элемент меньше или равен key), вставляется key.

Временная сложность: O(n²)
Почему O(n²): Каждый элемент вставляется в отсортированную часть массива. Для этого внутренний цикл сдвигает элементы, пока не найдёт место вставки. В худшем случае (если массив изначально упорядочен в обратном порядке) внутренний цикл выполняет до i итераций на каждом шаге, что в сумме даёт O(n²).



### 4) Сортировка Шелла (Shellsort) — является модификацией сортировки вставками, сортирует между собой элементы, стоящие на местах, кратных определённому шагу.
Алгоритм разбит на две функции.
- insertion_sort_gap выполняет сортировку вставками не для всего массива подряд, а проходится по элементам с фиксированным шагом (gap), начиная с позиции start. Это соответствует логике сортировки подсписки, образованные элементами на расстоянии шага.
- shell_sort управляет выбором шага gap, на каждом шаге разбивает массив на несколько таких подсписков (от 0 до gap-1) и вызывает insertion_sort_gap для каждого.

Временная сложность: O(n^1.5)
Почему O(n^1.5): Алгоритм выполняет несколько проходов сортировки вставками с разными шагами (gap). За счёт уменьшения количества сравнений при больших шагах время работы сокращается по сравнению с обычной вставкой (O(n²)), но остаётся больше, чем у алгоритмов O(n log n), примерно O(n^1.5).



### 5)Быстрая сортировка (Quick Sort) — один из самых известных и широко используемых алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них.

Алгоритм:
-Основная функция — quickSort, которая принимает массив и индексы начала и конца сортируемой части.
-Функция partition выбирает опорный элемент (pivot), здесь это последний элемент в текущем подмассиве.
-В цикле элементы, меньше опорного, перемещаются влево, больше — вправо.
-После циклов опорный элемент ставится на своё "правильное" место, и функция возвращает его индекс.
-Затем quickSort рекурсивно вызывается для левой и правой частей массива, разделённых опорным элементом.
-Рекурсия продолжается, пока подмассивы не станут слишком маленькими для дальнейшей сортировки.

Временная сложность: O(n log n)
Почему O(n log n): Массив делится на две части относительно опорного элемента (pivot). На каждом уровне рекурсии выполняется O(n) операций для разделения, а глубина рекурсии примерно log n, так как массив делится пополам. Итого: O(n) × O(log n) = O(n log n).


### 6)Пирамидальная сортировка — алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.

Алгоритм:
-Функция heapify поддерживает свойство кучи (максимальной куче в данном случае) начиная с индекса i для поддерева размером n.
  - Выбирается текущий узел как «наибольший» по сравнению с его левым и правым потомками.
  - Если какой-то из потомков больше текущего, меняются местами и рекурсивно вызывается heapify для этого поддерева.
-В heapSort сначала создаётся максимальная куча из входного массива, вызывая heapify для всех не листовых узлов в обратном порядке (середина массива к началу).
-Затем происходит сортировка:
  - Самый большой элемент (корень кучи) меняется с последним элементом массива.
  - Размер рассматриваемой кучи уменьшается на 1.
  - Для нового корня вызывается heapify, чтобы поддержать максимальную кучу.
-В конце функция main выводит отсортированный массив.

Временная сложность: O(n log n)
Почему O(n log n): Построение кучи занимает O(n) времени, а извлечение каждого из n элементов требует перестройки кучи за O(log n). Таким образом, итоговая сложность: O(n) + O(n log n) ≈ O(n log n).




### 7)Последовательный (линейный) поиск — простейший вид поиска заданного элемента на некотором множестве. Осуществляется путём последовательного сравнения очередного рассматриваемого значения с искомым до тех пор, пока эти значения не совпадут. Этот метод является наименее эффективным, так как его временная сложность составляет O(n), где n — количество элементов в списке. Однако он прост в реализации и может быть полезен для небольших списков или в тех случаях, когда данные не отсортированы.

Алгоритм:
-Функция linear_search принимает два аргумента: список arr и целевой элемент target. Она перебирает все элементы списка по порядку, сравнивая каждый элемент с target. Если элемент совпадает с искомым, функция возвращает индекс этого элемента, что означает, что поиск завершился успешно. Если цикл завершился без нахождения искомого элемента, функция возвращает -1, что означает, что элемент не найден в списке.
-Затем создается список numbers с несколькими числами. Указан искомый элемент 58. Функция вызывается для поиска этого элемента. В результате программа выводит, на какой позиции находится найденный элемент или сообщает, что его нет в списке.

Временная сложность: O(n)
Почему O(n): Алгоритм проверяет элементы поочерёдно, пока не найдёт нужный или не дойдёт до конца списка. В худшем случае нужно просмотреть все n элементов, значит сложность — O(n).



### 8) Бинарный (двоичный, дихотомический) поиск — это поиск заданного элемента на упорядоченном множестве, осуществляемый путём неоднократного деления этого множества на две части таким образом, что искомый элемент попадает в одну из этих частей. Поиск заканчивается при совпадении искомого элемента с элементом, который является границей между частями множества или при отсутствии искомого элемента. Преимуществом бинарного поиска является более низкая трудоёмкость по сравнению с последовательным поиском. Недостаток заключается в том, что он применим только на отсортированных множествах.

Алгоритм:
1.Инициализировать low = 0 и high = len(arr) - 1.
2.Выполнять поиск, пока low не превысит high.
3.В каждой итерации вычислять середину mid.
4.Сравнивать элемент arr[mid] с target.
5.Обновлять границы поиска по результату сравнения.
6.Если элемент найден — вернуть индекс.
7.Если нет — вернуть -1.

Временная сложность: O(log n)
Почему O(log n): На каждом шаге массив делится пополам, и поиск продолжается только в одной из половин. Количество шагов, необходимых для уменьшения диапазона до одного элемента, равно log₂n, поэтому сложность — O(log n).



### 9)Интерполирующий поиск — это алгоритм поиска для отсортированных наборов данных, таких как массивы или списки. Он предсказывает позицию нужного элемента на основе разницы значений. Эффективен, если элементы распределены достаточно равномерно.
Алгоритм интерполирующего поиска
1.Инициализировать границы поиска: low = 0, high = размер массива - 1.
2.Пока low <= high и искомое значение x лежит в диапазоне arr[low] и arr[high]:
3.Если low == high и элемент равен x, вернуть low, иначе вернуть -1.

Временная сложность: O(log log n)
Почему O(log log n): Алгоритм вычисляет позицию искомого элемента на основе распределения значений, и при равномерных данных каждый шаг сокращает диапазон быстрее, чем в бинарном поиске. В итоге количество шагов растёт логарифмом от логарифма n.



### 10) Поиск по Фибоначчи — это эффективный алгоритм поиска, используемый для нахождения целевого значения в отсортированной коллекции, такой как массив или список. По принципу он аналогичен бинарному поиску, но использует числа Фибоначчи для определения позиций для сравнения.

Алгоритм поиска по Фибоначчи

1. Определить минимальное число Фибоначчи, которое больше либо равно длине отсортированного массива.
2. Инициализировать переменные для двух предыдущих чисел Фибоначчи и текущего числа.
3. Установить смещение (offset) на -1, чтобы отслеживать левую границу текущего окна поиска.
4. Пока текущее число Фибоначчи больше 1, выполнять:
   - Вычислить индекс для сравнения как минимум между (offset + предыдущее предыдущее число Фибоначчи) и концом массива.
   - Сравнить элемент массива по этому индексу с искомым значением.
   - Если элемент меньше искомого, сдвинуть окно поиска вправо, обновив числа Фибоначчи и offset.
   - Если элемент больше искомого, сдвинуть окно поиска влево, обновив числа Фибоначчи соответствующим образом.
   - Если элемент равен искомому, вернуть индекс.
5. После цикла проверить последний потенциальный элемент и вернуть индекс, если он совпадает с искомым значением.
6. Если элемент не найден, вернуть индикатор отсутствия (например, -1).

Временная сложность: O(log n)
Почему O(log n): Поиск делит массив на части по числам Фибоначчи. Каждое деление уменьшает диапазон поиска в несколько раз, аналогично бинарному поиску, поэтому количество шагов пропорционально log n.


### 11)Сортировка вставками (Insertion Sort)- — алгоритм строит отсортированную часть списка, постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место.

Алгоритм:
 - Алгоритм строит отсортированную часть списка, начиная с первого элемента. Каждый новый элемент вставляется в правильное место среди уже отсортированных.
 - Внешний цикл for проходит по n-1 элементам.
 - Внутренний цикл while в худшем случае (массив отсортирован в обратном порядке) может выполнить до i итераций на i-ой итерации внешнего цикла.

Временная сложность: O(n²)
Почему O(n²): Алгоритм проходит по всем элементам массива (внешний цикл — n итераций). Для каждого элемента выполняется внутренний цикл, который сравнивает его с уже отсортированной частью массива и сдвигает элементы, пока не найдёт нужную позицию. В худшем случае (если массив отсортирован в обратном порядке) внутренний цикл выполняется до n раз на каждой итерации внешнего цикла. Следовательно, общее число операций пропорционально n × n = O(n²).

