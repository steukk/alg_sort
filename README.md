Работа Штойк Валерии, группа УИБО-14-24

1) Сортировка выбором (Selection Sort) — на каждом шаге алгоритма находят минимальный элемент среди последних и меняют его местами с текущим элементом в массиве алгоритм на с++
При запуске кода на C++ на примере массив [64, 25, 12, 22, 11], получим отсортированный массив [11, 12, 22, 25, 64] 

Анализ алгоритма сортировки выбором:
Алгоритм последовательно перебирает элементы массива и находит минимальный элемент среди ещё не обработанных частей массива. Найденный минимальный элемент помещается на своё правильное место, начиная с первого индекса неотсортированного участка.
На первом шаге алгоритм рассматривает всю длину массива и выбирает минимальное значение (например, число 11), которое заменяет собой первое значение массива.
Далее начинается обработка следующего фрагмента массива, начиная со второго элемента. Опять же находится минимальное значение среди оставшихся элементов (например, теперь это 12) и оно ставится на второе место.
Процесс продолжается для каждого шага до тех пор, пока вся длина массива не будет отсортирована.

Алгоритм имеет временную сложность: O(n2), потому что включает два вложенных цикла:
Один внешний цикл для выбора начала отсортированной части.
Один внутренний цикл для поиска минимального элемента среди оставшихся.


2) Сортировка обменом (пузырьком) (Bubble Sort) — алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Процесс повторяется до тех
пор, пока список полностью не отсортируется.
Анализ алгоритма сортировки обменом:
-Сначала определяется длина списка с помощью len(arr).
-Внешний цикл устанавливает число проходов по всему списку, так как каждый проход гарантирует размещение одного наибольшего элемента в конце.
-Внутренний цикл проходит по элементам, которые ещё не отсортированы (уменьшается на i, количество уже отсортированных элементов).
-Каждый раз сравниваются пары соседних элементов: если левый больше правого, они меняются местами.
-Итерации повторяются, пока весь список не станет отсортированным — когда за один проход не произойдет ни одной перестановки.

Временная сложность: Пузырьковая сортировка в худшем и среднем случае имеет временную сложность O(n2), потому что она использует вложенные циклы, каждый из которых зависит от размера списка nn.

3)Сортировка слиянием (Merge Sort) — алгоритм состоит в разделении массива пополам, сортировке половин и их слиянии.

Алгоритм сортировки вставками начинает с предположения, что первый элемент отсортирован. Затем он поочерёдно берёт каждый следующий элемент массива (с индексом i начиная с 1) и вставляет его в уже отсортированную часть массива (справа от начала до i-1).
Для каждого элемента key, внутренний цикл перемещается по отсортированной части массива слева направо и сдвигает элементы, которые больше key, вправо, чтобы освободить место для key. Когда подходящее место найдено (то есть элемент меньше или равен key), вставляется key.

Временная сложность алгоритма сортировки вставками — O(n2).

4) Сортировка слиянием (Merge Sort) — алгоритм состоит в разделении массива пополам, сортировке половин и их слиянии
Алгоритм: Сортировка слиянием рекурсивно делит массив на две половины, пока не останется отдельный элемент (или пустой подмассив). Затем начинается процесс слияния: две отсортированные подчасти объединяются в один отсортированный массив.
В коде функция merge_sort разбивает массив на меньшие части, вызывая сама себя для левой и правой половин. После того как обе половины отсортированы, вызывается функция merge, которая объединяет их в отсортированный массив.
Функция merge создаёт два временных массива для двух частей, затем последовательно сравнивает элементы из этих массивов и записывает меньший в исходный массив. Оставшиеся элементы копируются после, если одна из частей уже полностью скопирована.

Временная сложность: O(nlogn).

5) Сортировка Шелла (Shellsort) — является модификацией сортировки вставками, сортирует между собой элементы, стоящие на местах, кратных определённому шагу.
Алгоритм разбит на две функции.
-insertion_sort_gap выполняет сортировку вставками не для всего массива подряд, а проходится по элементам с фиксированным шагом (gap), начиная с позиции start. Это соответствует логике сортировки подсписки, образованные элементами на расстоянии шага.
-shell_sort управляет выбором шага gap, на каждом шаге разбивает массив на несколько таких подсписков (от 0 до gap-1) и вызывает insertion_sort_gap для каждого.
Временная сложность алгоритма: O(n^1.5)
